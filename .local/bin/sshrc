#!/usr/bin/env bash

function ssh_into_host() {
  
  local LOCAL_SSHRC_DIR="${LOCAL_SSHRC_DIR:=~}"
  if [ -f $LOCAL_SSHRC_DIR/sshrc ]; then
    local LOCAL_FILES=sshrc
    if [ -d $LOCAL_SSHRC_DIR/sshrc.d ]; then
      LOCAL_FILES="$LOCAL_FILES sshrc.d"
    fi
    SIZE=$(tar cfz - -h -C "$LOCAL_SSHRC_DIR" "$LOCAL_FILES" | wc -c)
    if [ "$SIZE" -gt 65536 ]; then
      printf "SSHrc.d and sshrc files must be smaller than 64kb\nCurrent size: %d bytes\n" "$SIZE"
      printf "SSHRC_DIR: %s\nFiles: %s\nFiles size: %s KiB\n" "$LOCAL_SSHRC_DIR" "$FILES" "$SIZE"
      exit 1
    else
      printf "LOCAL_SSHRC_DIR: %s\nFiles: %s\nFiles size: %s KiB\n" "$LOCAL_SSHRC_DIR" "$FILES" "$SIZE"
    fi
  else
    echo >&2 $"No such file: $LOCAL_SSHRC_DIR/sshrc"
    exit 1
  fi
  
  ssh -t "$DOMAIN" $SSH_ARGS "
    
    command -v openssl > /dev/null 2>&1 || { printf \"SSHrc requires openssl to be installed. Exiting.\"; exit 1; }
    
    export REMOTE_SSHRC_DIR=\$(mktemp -d -t .$(whoami)-sshrc-XXXX)
    export REMOTE_SSHRC_CLEANUP=\$REMOTE_SSHRC_DIR
    trap \"rm -rf \$REMOTE_SSHRC_CLEANUP; exit\" 0

    echo $'"$(cat "$0" | openssl enc -base64)"' | tr -s ' ' $'\n' | openssl enc -base64 -d > \$REMOTE_SSHRC_DIR/sshrc
    chmod +x \$REMOTE_SSHRC_DIR/sshrc

    echo $'"$( cat <<-'SSHRC_BASHRC_GENERATION' | openssl enc -base64
      if [ -r /etc/profile ]; then
        source /etc/profile; 
      fi
      if [ -r ~/.bash_profile ]; then
        source ~/.bash_profile
      elif [ -r ~/.bash_login ]; then 
        source ~/.bash_login
      elif [ -r ~/.profile ]; then 
        source ~/.profile
      fi
      export PATH=$PATH:$REMOTE_SSHRC_DIR
      source $REMOTE_SSHRC_DIR/sshrc;
SSHRC_BASHRC_GENERATION
    )"' | tr -s ' ' $'\n' | openssl enc -base64 -d > \$REMOTE_SSHRC_DIR/sshrc.bashrc

    echo $'"$( cat << 'BASH_SSHRC_GENERATION' | openssl enc -base64
      #!/usr/bin/env bash
      exec bash --rcfile <(echo '
      if [ -r /etc/profile ]; then
        source /etc/profile; 
      fi
      if [ -r ~/.bash_profile ]; then
        source ~/.bash_profile
      elif [ -r ~/.bash_login ]; then 
        source ~/.bash_login
      elif [ -r ~/.profile ]; then 
        source ~/.profile
      fi
      source '$REMOTE_SSHRC_DIR'/sshrc;
      export PATH=$PATH:'$REMOTE_SSHRC_DIR'
      ') "$@"
BASH_SSHRC_GENERATION
    )"' | tr -s ' ' $'\n' | openssl enc -base64 -d > \$REMOTE_SSHRC_DIR/bashsshrc
      chmod +x \$REMOTE_SSHRC_DIR/bashsshrc

      echo $'"$(tar czf - -h -C $LOCAL_SSHRC_DIR $LOCAL_FILES | openssl enc -base64)"' | tr -s ' ' $'\n' | openssl enc -base64 -d | tar mxzf - -C \$REMOTE_SSHRC_DIR
      export REMOTE_SSHRC_DIR=\$REMOTE_SSHRC_DIR
      echo \"$CMD_ARG\" >> \$REMOTE_SSHRC_DIR/sshrc.bashrc
      bash --rcfile \$REMOTE_SSHRC_DIR/sshrc.bashrc
      clear
      "
}

function sshrc_parse() {
  while [[ -n $1 ]]; do
    case $1 in
      -b | -c | -D | -E | -e | -F | -I | -i | -L | -l | -m | -O | -o | -p | -Q | -R | -S | -W | -w )
        SSHARGS="$SSHARGS $1 $2"; shift ;;
      -* )
        SSHARGS="$SSHARGS $1" ;;
      *)
        if [ -z "$DOMAIN" ]; then
         DOMAIN="$1"
        else
          local SEMICOLON=$([[ "$@" = *[![:space:]]* ]] && echo '; ')
          CMD_ARG="$@$SEMICOLON exit"
          return;
        fi
        ;;
    esac
    shift
  done
  if [ -z $DOMAIN ]; then
    ssh $SSHARGS; exit 1;
  fi
}

sshrc_parse "$@"
ssh_into_host
